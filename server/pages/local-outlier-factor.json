{"pageProps":{"postData":{"id":"local-outlier-factor","contentHtml":"<h1>Local outlier factor from scratch in Python</h1>\n<h3>Overview</h3>\n<p>Local outlier factor (LOF) is an anomaly detection algorithm which can give you an idea of how similar an item is to other items in a dataset.</p>\n<p>The algorithm essentialy compares the density of an item's neighbourhood (how close the items in an area are to eachother) to the density of the item's neighbour's neighbourhoods.</p>\n<h3>Why use local outlier factor?</h3>\n<p>LOF is great for datasets with several clusters because it only compares an item to other items in it's locality.</p>\n<p>This means that an item that is a large distance from it's nearest neighbours may not be classified as an outlier so long as it's neighbours are also large distances from their nearest neighbours.</p>\n<p>This image shows how an outlier in one area of a dataset may not be an outlier in another area of the dataset:</p>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/5/59/LOF.svg/1024px-LOF.svg.png\" width=\"450\" alt=\"Local outlier factor diagram\">\n<figcaption center=\"\" class=\"figure-caption text-center\">Source: Wikipedia</figcaption>\n<p><br>\n<br>\n</p>\n<h3>Implenting the algorithm in Python</h3>\n<p>This is how LOF is implemented in the <a href=\"https://github.com/PaulTreanor/openhands\">OpenHands project</a>.</p>\n<p>The algorithm is split into 3 methods corrosponding to the 3 maths functions from the <a href=\"https://en.wikipedia.org/wiki/Local_outlier_factor\">algorithm's Wikipedia page</a>.</p>\n<p>The LOF method takes 4 arguments:</p>\n<ul class=\"pl-5\">\n  <li>A (the item to be classified, as a list of features)</li>\n  <li>a list of A's nearest neighbours</li>\n  <li>an instance of the KNN classifier</li>\n  <li>a value for K</li>\n</ul>\n<h5>1. Reachability distance</h5>\n<img src=\"/images/lof/rdist.png\" alt=\"reachability distance\">\n<p><br>\n</p>\n<p>The reachability distance between items A and B is the distance between B and it's Kth nearest neighbour or the distance between A and B (whichever is larger).</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span>  <span class=\"hljs-title function_\">reachability_distance</span>(<span class=\"hljs-params\">A, B, classifier, k</span>):\n    B_n_neighbours = classifier.get_knn(B)\n    k_dist = <span class=\"hljs-built_in\">max</span>([distance.euclidean(B, n) <span class=\"hljs-keyword\">for</span> n <span class=\"hljs-keyword\">in</span> B_n_neighbours])\n    AB_dist = distance.euclidean(A, B)\n    r_distance = <span class=\"hljs-built_in\">max</span>(k_dist, AB_dist)\n    <span class=\"hljs-keyword\">return</span> r_distance\n</code></pre>\n<p><br>\n</p>\n<h5>2. Local reachability density</h5>\n<img src=\"/images/lof/lrd.png\" alt=\"local reachability density\">\n<p><br>\n</p>\n<p>Local reachability density is the inverse of the average reachability distance between A and each of it's K nearest neighbours.</p>\n<pre><code class=\"hljs language-python\">\n<span class=\"hljs-keyword\">def</span>  <span class=\"hljs-title function_\">local_r_density</span>(<span class=\"hljs-params\">A, nearest_neighbours, classifier, k</span>): <span class=\"hljs-comment\"># Local reachability density</span>\n    r_distance_list = []\n    <span class=\"hljs-keyword\">for</span> B <span class=\"hljs-keyword\">in</span> nearest_neighbours:\n        B_r_distance = rDistance(A, B, classifier, k)\n        r_distance_list.append(B_r_distance)\n    avg_r_distance = <span class=\"hljs-built_in\">sum</span>(r_distance_list)/k\n    local_r_density = <span class=\"hljs-number\">1.0</span>/avg_r_distance\n    <span class=\"hljs-keyword\">return</span> local_r_density\n</code></pre>\n<p><br>\n</p>\n<h5>3. Local outlier factor</h5>\n<img src=\"/images/lof/lof.png\" alt=\"local outlier factor\">\n<p><br>\nThe local outlier factor of object A can then be defined as the average local reachability-density of each of Aâ€™s neighbours divided by the local reachability-density of A.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span>  <span class=\"hljs-title function_\">local_outlier_factor</span>(<span class=\"hljs-params\">A, nearest_neighbours, classifier, k</span>):\n    A_local_r_density = local_r_density(A, nearest_neighbours, classifier, k)\n    local_r_density_list = []\n    <span class=\"hljs-keyword\">for</span> B <span class=\"hljs-keyword\">in</span> nearest_neighbours:\n        B_n_neighbours = classifier.get_knn(B)\n        B_local_r_density = local_r_density(B, B_n_neighbours, classifier, k)\n        local_r_density_list.append(B_local_r_density)\n    local_r_density_total = <span class=\"hljs-built_in\">sum</span>(local_r_density_list)\n    divisor = A_local_r_density*k\n    local_outlier_factor = local_r_density_total/divisor\n    local_outlier_factor = -local_outlier_factor\n    <span class=\"hljs-keyword\">return</span> local_outlier_factor\n</code></pre>\n<p><br>\n</p>\n<h3>Performance</h3>\n<p>LOF is slow because since it essentially runs KNN <em>k<sup>2</sup>+1</em> times. If performance is important it may be worth looking at the <a href=\"https://doi.org/10.1145/342009.335388\">local <em>distance</em> outlier factor</a> algorithm instead.</p>\n<h3>Resources</h3>\n<ol class=\"pl-5\">\n  <li><a href=\"https://en.wikipedia.org/wiki/Local_outlier_factor\">Local outlier factor's excellent Wikipedia page.</a></li>\n  <li><a href=\"https://benwtrent.github.io/2019/04/26/outlier-detection-from-scratch/\">Benjamin Trent's very elegant implementation of LOF.</a></li>\n  <li><a href=\"https://doi.org/10.1145%2F335191.335388\">The OG local outlier factor paper by Breunig and Kriegel.</a></li>\n</ol>","title":"Local outlier factor from scratch in Python","short":"Explaination and implementation of the local outlier factor algorithm.","date":"2021-06-03","slug":"local-outlier-factor","createdAt":"2021-06-03","img":"blog-2.jpg","tags":["Code"]}},"__N_SSG":true}