<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><meta name="description" content="My personal website where I keep my notes and thoughts."/><meta name="og:title" content="Paul Treanor"/><meta name="twitter:card" content="summary_large_image"/><title>Local outlier factor from scratch in Python</title><meta name="next-head-count" content="7"/><link rel="preload" href="/_next/static/css/118a0aa97ee3b395.css" as="style"/><link rel="stylesheet" href="/_next/static/css/118a0aa97ee3b395.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-481ef0d25a716735.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1693ab7fc31cdd21.js" defer=""></script><script src="/_next/static/chunks/562-d0bcd15ec5190dc9.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bid%5D-6436168c0c572d74.js" defer=""></script><script src="/_next/static/Ma5ANmsAsfcwYxqrID0tu/_buildManifest.js" defer=""></script><script src="/_next/static/Ma5ANmsAsfcwYxqrID0tu/_ssgManifest.js" defer=""></script></head><body><div id="__next"><script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script><script nomodule="" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script><div class="mx-2 md:mx-20 lg:mx-40 font-open-sans mb-32"><header class="max-w-2xl mx-auto"><div class="mt-10 mb-8"><a href="/"><div class="text-4xl">üè†</div></a></div></header><main><div class="max-w-2xl mx-auto"><h5 class="text-slate-600 font-normal mb-5"><time dateTime="2021-06-03">June 3, 2021</time></h5><div><h1>Local outlier factor from scratch in Python</h1>
<h3>Overview</h3>
<p>Local outlier factor (LOF) is an anomaly detection algorithm which can give you an idea of how similar an item is to other items in a dataset.</p>
<p>The algorithm essentialy compares the density of an item's neighbourhood (how close the items in an area are to eachother) to the density of the item's neighbour's neighbourhoods.</p>
<h3>Why use local outlier factor?</h3>
<p>LOF is great for datasets with several clusters because it only compares an item to other items in it's locality.</p>
<p>This means that an item that is a large distance from it's nearest neighbours may not be classified as an outlier so long as it's neighbours are also large distances from their nearest neighbours.</p>
<p>This image shows how an outlier in one area of a dataset may not be an outlier in another area of the dataset:</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/59/LOF.svg/1024px-LOF.svg.png" width="450" alt="Local outlier factor diagram">
<figcaption center="" class="figure-caption text-center">Source: Wikipedia</figcaption>
<p><br>
<br>
</p>
<h3>Implenting the algorithm in Python</h3>
<p>This is how LOF is implemented in the <a href="https://github.com/PaulTreanor/openhands">OpenHands project</a>.</p>
<p>The algorithm is split into 3 methods corrosponding to the 3 maths functions from the <a href="https://en.wikipedia.org/wiki/Local_outlier_factor">algorithm's Wikipedia page</a>.</p>
<p>The LOF method takes 4 arguments:</p>
<ul class="pl-5">
  <li>A (the item to be classified, as a list of features)</li>
  <li>a list of A's nearest neighbours</li>
  <li>an instance of the KNN classifier</li>
  <li>a value for K</li>
</ul>
<h5>1. Reachability distance</h5>
<img src="/images/lof/rdist.png" alt="reachability distance">
<p><br>
</p>
<p>The reachability distance between items A and B is the distance between B and it's Kth nearest neighbour or the distance between A and B (whichever is larger).</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span>  <span class="hljs-title function_">reachability_distance</span>(<span class="hljs-params">A, B, classifier, k</span>):
    B_n_neighbours = classifier.get_knn(B)
    k_dist = <span class="hljs-built_in">max</span>([distance.euclidean(B, n) <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> B_n_neighbours])
    AB_dist = distance.euclidean(A, B)
    r_distance = <span class="hljs-built_in">max</span>(k_dist, AB_dist)
    <span class="hljs-keyword">return</span> r_distance
</code></pre>
<p><br>
</p>
<h5>2. Local reachability density</h5>
<img src="/images/lof/lrd.png" alt="local reachability density">
<p><br>
</p>
<p>Local reachability density is the inverse of the average reachability distance between A and each of it's K nearest neighbours.</p>
<pre><code class="hljs language-python">
<span class="hljs-keyword">def</span>  <span class="hljs-title function_">local_r_density</span>(<span class="hljs-params">A, nearest_neighbours, classifier, k</span>): <span class="hljs-comment"># Local reachability density</span>
    r_distance_list = []
    <span class="hljs-keyword">for</span> B <span class="hljs-keyword">in</span> nearest_neighbours:
        B_r_distance = rDistance(A, B, classifier, k)
        r_distance_list.append(B_r_distance)
    avg_r_distance = <span class="hljs-built_in">sum</span>(r_distance_list)/k
    local_r_density = <span class="hljs-number">1.0</span>/avg_r_distance
    <span class="hljs-keyword">return</span> local_r_density
</code></pre>
<p><br>
</p>
<h5>3. Local outlier factor</h5>
<img src="/images/lof/lof.png" alt="local outlier factor">
<p><br>
The local outlier factor of object A can then be defined as the average local reachability-density of each of A‚Äôs neighbours divided by the local reachability-density of A.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span>  <span class="hljs-title function_">local_outlier_factor</span>(<span class="hljs-params">A, nearest_neighbours, classifier, k</span>):
    A_local_r_density = local_r_density(A, nearest_neighbours, classifier, k)
    local_r_density_list = []
    <span class="hljs-keyword">for</span> B <span class="hljs-keyword">in</span> nearest_neighbours:
        B_n_neighbours = classifier.get_knn(B)
        B_local_r_density = local_r_density(B, B_n_neighbours, classifier, k)
        local_r_density_list.append(B_local_r_density)
    local_r_density_total = <span class="hljs-built_in">sum</span>(local_r_density_list)
    divisor = A_local_r_density*k
    local_outlier_factor = local_r_density_total/divisor
    local_outlier_factor = -local_outlier_factor
    <span class="hljs-keyword">return</span> local_outlier_factor
</code></pre>
<p><br>
</p>
<h3>Performance</h3>
<p>LOF is slow because since it essentially runs KNN <em>k<sup>2</sup>+1</em> times. If performance is important it may be worth looking at the <a href="https://doi.org/10.1145/342009.335388">local <em>distance</em> outlier factor</a> algorithm instead.</p>
<h3>Resources</h3>
<ol class="pl-5">
  <li><a href="https://en.wikipedia.org/wiki/Local_outlier_factor">Local outlier factor's excellent Wikipedia page.</a></li>
  <li><a href="https://benwtrent.github.io/2019/04/26/outlier-detection-from-scratch/">Benjamin Trent's very elegant implementation of LOF.</a></li>
  <li><a href="https://doi.org/10.1145%2F335191.335388">The OG local outlier factor paper by Breunig and Kriegel.</a></li>
</ol></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"local-outlier-factor","contentHtml":"\u003ch1\u003eLocal outlier factor from scratch in Python\u003c/h1\u003e\n\u003ch3\u003eOverview\u003c/h3\u003e\n\u003cp\u003eLocal outlier factor (LOF) is an anomaly detection algorithm which can give you an idea of how similar an item is to other items in a dataset.\u003c/p\u003e\n\u003cp\u003eThe algorithm essentialy compares the density of an item's neighbourhood (how close the items in an area are to eachother) to the density of the item's neighbour's neighbourhoods.\u003c/p\u003e\n\u003ch3\u003eWhy use local outlier factor?\u003c/h3\u003e\n\u003cp\u003eLOF is great for datasets with several clusters because it only compares an item to other items in it's locality.\u003c/p\u003e\n\u003cp\u003eThis means that an item that is a large distance from it's nearest neighbours may not be classified as an outlier so long as it's neighbours are also large distances from their nearest neighbours.\u003c/p\u003e\n\u003cp\u003eThis image shows how an outlier in one area of a dataset may not be an outlier in another area of the dataset:\u003c/p\u003e\n\u003cimg src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/5/59/LOF.svg/1024px-LOF.svg.png\" width=\"450\" alt=\"Local outlier factor diagram\"\u003e\n\u003cfigcaption center=\"\" class=\"figure-caption text-center\"\u003eSource: Wikipedia\u003c/figcaption\u003e\n\u003cp\u003e\u003cbr\u003e\n\u003cbr\u003e\n\u003c/p\u003e\n\u003ch3\u003eImplenting the algorithm in Python\u003c/h3\u003e\n\u003cp\u003eThis is how LOF is implemented in the \u003ca href=\"https://github.com/PaulTreanor/openhands\"\u003eOpenHands project\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe algorithm is split into 3 methods corrosponding to the 3 maths functions from the \u003ca href=\"https://en.wikipedia.org/wiki/Local_outlier_factor\"\u003ealgorithm's Wikipedia page\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe LOF method takes 4 arguments:\u003c/p\u003e\n\u003cul class=\"pl-5\"\u003e\n  \u003cli\u003eA (the item to be classified, as a list of features)\u003c/li\u003e\n  \u003cli\u003ea list of A's nearest neighbours\u003c/li\u003e\n  \u003cli\u003ean instance of the KNN classifier\u003c/li\u003e\n  \u003cli\u003ea value for K\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5\u003e1. Reachability distance\u003c/h5\u003e\n\u003cimg src=\"/images/lof/rdist.png\" alt=\"reachability distance\"\u003e\n\u003cp\u003e\u003cbr\u003e\n\u003c/p\u003e\n\u003cp\u003eThe reachability distance between items A and B is the distance between B and it's Kth nearest neighbour or the distance between A and B (whichever is larger).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e  \u003cspan class=\"hljs-title function_\"\u003ereachability_distance\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eA, B, classifier, k\u003c/span\u003e):\n    B_n_neighbours = classifier.get_knn(B)\n    k_dist = \u003cspan class=\"hljs-built_in\"\u003emax\u003c/span\u003e([distance.euclidean(B, n) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e n \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e B_n_neighbours])\n    AB_dist = distance.euclidean(A, B)\n    r_distance = \u003cspan class=\"hljs-built_in\"\u003emax\u003c/span\u003e(k_dist, AB_dist)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e r_distance\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cbr\u003e\n\u003c/p\u003e\n\u003ch5\u003e2. Local reachability density\u003c/h5\u003e\n\u003cimg src=\"/images/lof/lrd.png\" alt=\"local reachability density\"\u003e\n\u003cp\u003e\u003cbr\u003e\n\u003c/p\u003e\n\u003cp\u003eLocal reachability density is the inverse of the average reachability distance between A and each of it's K nearest neighbours.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e  \u003cspan class=\"hljs-title function_\"\u003elocal_r_density\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eA, nearest_neighbours, classifier, k\u003c/span\u003e): \u003cspan class=\"hljs-comment\"\u003e# Local reachability density\u003c/span\u003e\n    r_distance_list = []\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e B \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e nearest_neighbours:\n        B_r_distance = rDistance(A, B, classifier, k)\n        r_distance_list.append(B_r_distance)\n    avg_r_distance = \u003cspan class=\"hljs-built_in\"\u003esum\u003c/span\u003e(r_distance_list)/k\n    local_r_density = \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e/avg_r_distance\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e local_r_density\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cbr\u003e\n\u003c/p\u003e\n\u003ch5\u003e3. Local outlier factor\u003c/h5\u003e\n\u003cimg src=\"/images/lof/lof.png\" alt=\"local outlier factor\"\u003e\n\u003cp\u003e\u003cbr\u003e\nThe local outlier factor of object A can then be defined as the average local reachability-density of each of A‚Äôs neighbours divided by the local reachability-density of A.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e  \u003cspan class=\"hljs-title function_\"\u003elocal_outlier_factor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eA, nearest_neighbours, classifier, k\u003c/span\u003e):\n    A_local_r_density = local_r_density(A, nearest_neighbours, classifier, k)\n    local_r_density_list = []\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e B \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e nearest_neighbours:\n        B_n_neighbours = classifier.get_knn(B)\n        B_local_r_density = local_r_density(B, B_n_neighbours, classifier, k)\n        local_r_density_list.append(B_local_r_density)\n    local_r_density_total = \u003cspan class=\"hljs-built_in\"\u003esum\u003c/span\u003e(local_r_density_list)\n    divisor = A_local_r_density*k\n    local_outlier_factor = local_r_density_total/divisor\n    local_outlier_factor = -local_outlier_factor\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e local_outlier_factor\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cbr\u003e\n\u003c/p\u003e\n\u003ch3\u003ePerformance\u003c/h3\u003e\n\u003cp\u003eLOF is slow because since it essentially runs KNN \u003cem\u003ek\u003csup\u003e2\u003c/sup\u003e+1\u003c/em\u003e times. If performance is important it may be worth looking at the \u003ca href=\"https://doi.org/10.1145/342009.335388\"\u003elocal \u003cem\u003edistance\u003c/em\u003e outlier factor\u003c/a\u003e algorithm instead.\u003c/p\u003e\n\u003ch3\u003eResources\u003c/h3\u003e\n\u003col class=\"pl-5\"\u003e\n  \u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Local_outlier_factor\"\u003eLocal outlier factor's excellent Wikipedia page.\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://benwtrent.github.io/2019/04/26/outlier-detection-from-scratch/\"\u003eBenjamin Trent's very elegant implementation of LOF.\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://doi.org/10.1145%2F335191.335388\"\u003eThe OG local outlier factor paper by Breunig and Kriegel.\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e","title":"Local outlier factor from scratch in Python","short":"Explaination and implementation of the local outlier factor algorithm.","date":"2021-06-03","slug":"local-outlier-factor","createdAt":"2021-06-03","img":"blog-2.jpg","tags":["Code"]}},"__N_SSG":true},"page":"/[id]","query":{"id":"local-outlier-factor"},"buildId":"Ma5ANmsAsfcwYxqrID0tu","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>